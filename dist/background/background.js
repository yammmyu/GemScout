let g=null,m=null,E=null,y=!1;chrome.runtime.onInstalled.addListener(()=>{console.log("GemScout extension installed (background)")});chrome.tabs.onUpdated.addListener((e,s,o)=>{E===e&&s.url&&y&&(console.log("üîÑ DEBUG: Tab URL changed, cancelling active analysis"),S("Tab navigation detected"))});chrome.tabs.onActivated.addListener(e=>{E&&E!==e.tabId&&y&&(console.log("üîÑ DEBUG: Active tab changed, cancelling analysis"),S("Switched to different tab"))});function S(e){console.log("‚ùå DEBUG: Cancelling active analysis:",e),y=!1,m&&(console.log("üóëÔ∏è DEBUG: Destroying active session..."),m.destroy().catch(s=>{console.log("‚ö†Ô∏è DEBUG: Error destroying session:",s)}),m=null),g&&(g.postMessage({type:"analysis_cancelled",reason:e,isComplete:!0}),console.log("üì® DEBUG: Sent cancellation message to popup")),E=null}chrome.runtime.onConnect.addListener(e=>{console.log("Port connected:",e.name),e.name==="popup-stream"&&(g=e,e.onDisconnect.addListener(()=>{console.log("Popup port disconnected"),g=null}))});function L(e){return new Promise(s=>chrome.storage.local.get(e,s))}function P(e){return new Promise(s=>chrome.storage.local.set(e,()=>s()))}async function A(e){try{const{gemscout_jobs:s=[]}=await L(["gemscout_jobs"]),o=[...s,...e];return await P({gemscout_jobs:o}),await P({lastJobAnalysis:{timestamp:Date.now()}}),o.length}catch(s){return console.error("appendJobsToStorage error",s),-1}}function k(e){const s=[];let o=e.trim();if((o.length>1e3||o.includes("}"))&&console.log("üîç DEBUG: tryExtractJsonObjects buffer preview:",{length:o.length,startsWithArray:o.startsWith("["),endsWithArray:o.endsWith("]"),preview:o.substring(0,200)+(o.length>200?"...":""),lastChars:o.slice(-50)}),o.startsWith("[")&&o.endsWith("]"))try{const n=JSON.parse(o);if(Array.isArray(n)&&n.length>0)return console.log("‚úÖ DEBUG: Successfully parsed complete JSON array with",n.length,"items"),s.push(...n),{extracted:s,remaining:""}}catch(n){console.log("‚ö†Ô∏è DEBUG: Failed to parse complete array:",n.message)}let U=0,p=0,t=!1,u=!1;for(let n=0;n<o.length;n++){const l=o[n];if(u){u=!1;continue}if(l==="\\"){u=!0;continue}if(l==='"'&&!u){t=!t;continue}if(!t){if(l==="{")p===0&&(U=n),p++;else if(l==="}"&&(p--,p===0)){const c=o.substring(U,n+1);try{const r=JSON.parse(c);r&&typeof r=="object"&&r.title&&r.company&&(console.log("‚úÖ DEBUG: Extracted valid job object:",{title:r.title,company:r.company}),s.push(r))}catch(r){console.log("‚ö†Ô∏è DEBUG: Failed to parse object:",c.substring(0,100),r.message)}}}}if(s.length>0){const n=o.lastIndexOf("}");n!==-1&&(o=o.substring(n+1))}return console.log("üìä DEBUG: Extraction result:",{extractedCount:s.length,remainingLength:o.length,jobTitles:s.map(n=>n==null?void 0:n.title).filter(Boolean)}),{extracted:s,remaining:o}}function j(e){console.log("üîß DEBUG: Normalizing job object:",{title:e==null?void 0:e.title,company:e==null?void 0:e.company,location:e==null?void 0:e.location,hasDescription:!!(e!=null&&e.description),hasLink:!!(e!=null&&e.link)});const s={title:e.title||"Unknown Title",company:e.company||"Unknown Company",location:e.location||"Unknown Location",link:e.link||e.applyUrl||"#",description:e.description||"No description available",salary:e.salary,skills:Array.isArray(e.skills)?e.skills:void 0,software:Array.isArray(e.software)?e.software:void 0,workingHours:e.workingHours};return console.log("‚úÖ DEBUG: Job normalized:",{title:s.title,company:s.company,location:s.location}),s}function C(e){return`
You are an expert job posting extractor. Given the page contents and links below, extract up to 50 job listings found on the page.
OUTPUT RULES (must follow strictly):
- Return ONLY a single JSON array (no explanation, no markdown).
- Each array item must be an object with at least: "title", "company", "location", "link", "description".
- Optional fields that may appear: "salary", "skills" (array of strings), "software" (array of strings), "workingHours".
- If a job is only visible behind a link that needs clicking for more detail, include {"needsClick": true, "clickLink": "<URL>"} for that item. Otherwise omit those keys.
- The "link" field should be an absolute URL to the job or the listing anchor.
- Keep descriptions concise (1-3 short paragraphs). Do not include HTML tags.
- If you cannot find any jobs, return an empty array: [].

PAGE DATA:
URL: ${e.url}
TITLE: ${e.pageTitle}
META: ${e.metaDescription}
TEXT: ${e.text.slice(0,1e5)}   // long text truncated to safe size
LINKS:
${e.links.slice(0,200).map(o=>`${o.text} -> ${o.href}`).join(`
`)}

Return only the JSON array now.
`}async function w(e,s=5,o){var G,U,p;if(console.log("üöÄ DEBUG: discoveryWithPromptAPI started"),console.log("üîç DEBUG: Input snapshot:",{url:e==null?void 0:e.url,textLength:(G=e==null?void 0:e.text)==null?void 0:G.length,linksCount:(U=e==null?void 0:e.links)==null?void 0:U.length}),console.log("üîç DEBUG: maxJobs:",s),console.log("üîç DEBUG: tabId:",o),y&&(console.log("‚ö†Ô∏è DEBUG: Cancelling existing analysis before starting new one"),S("New analysis requested"),await new Promise(t=>setTimeout(t,100))),y=!0,E=o||null,typeof LanguageModel>"u"){const t="LanguageModel (Prompt API) is not available in this context.";return console.error("‚ùå DEBUG:",t),g&&g.postMessage({type:"analysis_error",error:t,isComplete:!0}),y=!1,E=null,Promise.reject(new Error(t))}console.log("‚úÖ DEBUG: LanguageModel is available");try{console.log("üîç DEBUG: Checking LanguageModel availability...");const t=await LanguageModel.availability();if(console.log("üîç DEBUG: LanguageModel availability result:",t),t==="unavailable"){const i="Prompt model unavailable on this device";return console.error("‚ùå DEBUG:",i),g&&g.postMessage({type:"analysis_error",error:i,isComplete:!0}),y=!1,E=null,Promise.reject(new Error(i))}console.log("‚úÖ DEBUG: Model availability confirmed, creating session...");const u=await LanguageModel.create();m=u,console.log("‚úÖ DEBUG: LanguageModel session created successfully");const n=C(e);console.log("üìù DEBUG: Prompt built, length:",n.length),console.log("üîç DEBUG: Prompt preview:",n.substring(0,500)+"...");const l=u.promptStreaming(n);console.log("üåä DEBUG: Streaming started...");let c="",r=0,d=0,h=((p=(await L(["gemscout_jobs"])).gemscout_jobs)==null?void 0:p.length)||0;console.log("üìä DEBUG: Initial stored jobs count:",h),g&&(g.postMessage({type:"analysis_status",message:"Analyzing page...",isComplete:!1}),console.log("üì® DEBUG: Sent analysis_status to popup")),console.log("üîÑ DEBUG: Starting stream processing loop...");for await(const i of l){if(!y||m!==u){console.log("‚ö†Ô∏è DEBUG: Analysis cancelled, breaking stream loop");break}if(d++,!i){console.log(`‚ö†Ô∏è DEBUG: Chunk ${d} is empty, skipping`);continue}const f=typeof i=="string"?i:(i==null?void 0:i.text)??(i==null?void 0:i.content)??JSON.stringify(i);d%100===0&&console.log(`üì¶ DEBUG: Chunk ${d} received:`,{type:typeof i,deltaLength:f==null?void 0:f.length,deltaPreview:f==null?void 0:f.substring(0,100)}),c+=f,(d%500===0||c.includes("}"))&&console.log("üìã DEBUG: Buffer updated, total length:",c.length);const{extracted:b,remaining:x}=k(c);if(console.log("‚öôÔ∏è DEBUG: JSON extraction attempt:",{extractedCount:b.length,remainingLength:x.length}),c=x,b.length){console.log(`‚ú® DEBUG: Found ${b.length} JSON objects to process`),console.log("üîç DEBUG: Extracted objects preview:",b.map(a=>({type:Array.isArray(a)?"array":typeof a,title:a==null?void 0:a.title,length:Array.isArray(a)?a.length:void 0})));const D=[];for(const a of b)if(a){if(Array.isArray(a))for(const B of a)B.title&&B.company&&D.push(j(B));else if(a.title&&a.company)D.push(j(a));else if(a.jobs&&Array.isArray(a.jobs))for(const B of a.jobs)B.title&&B.company&&D.push(j(B))}if(D.length){r+=1,console.log(`üíæ DEBUG: Publishing ${D.length} jobs (batch ${r})`);const a=await A(D);h=a>0?a:h,console.log("üìä DEBUG: Jobs stored successfully, new total:",h),g&&(g.postMessage({type:"jobs_update",count:h,jobs:D,batchNumber:r,isComplete:!1}),console.log(`üì® DEBUG: Sent jobs_update to popup (batch ${r}, ${D.length} jobs)`))}else console.log("üö´ DEBUG: No valid jobs to publish from this extraction")}}console.log(`üèÅ DEBUG: Stream processing completed, total chunks: ${d}`),console.log(`üßπ DEBUG: Final flush - buffer length: ${c.length}`);const{extracted:v}=k(c);if(console.log(`üîç DEBUG: Final extraction yielded ${v.length} objects`),v.length){const i=v.flat().filter(f=>f.title&&f.company).map(j);console.log(`‚ú® DEBUG: Final jobs after filtering: ${i.length}`),i.length&&(await A(i),console.log("üíæ DEBUG: Final jobs stored successfully"),g&&(g.postMessage({type:"jobs_update",count:h+i.length,jobs:i,batchNumber:r+1,isComplete:!1}),console.log("üì® DEBUG: Sent final jobs_update to popup")))}console.log("‚úÖ DEBUG: Analysis complete, sending final completion message"),g&&(g.postMessage({type:"jobs_update",count:h,jobs:[],batchNumber:r,isComplete:!0}),console.log("üèÅ DEBUG: Sent completion message to popup")),console.log("üóëÔ∏è DEBUG: Destroying LanguageModel session..."),m===u?(await u.destroy(),m=null,y=!1,E=null,console.log("‚úÖ DEBUG: Session destroyed, discoveryWithPromptAPI completed successfully")):console.log("üîÑ DEBUG: Session was already replaced, skipping cleanup")}catch(t){if(console.error("‚ùå DEBUG: Error in discoveryWithPromptAPI:",t),m)try{await m.destroy(),console.log("üóëÔ∏è DEBUG: Cleaned up session after error")}catch(u){console.log("‚ö†Ô∏è DEBUG: Error destroying session:",u)}throw m=null,y=!1,E=null,console.error("discoveryWithPromptAPI error:",t),g&&g.postMessage({type:"analysis_error",error:(t==null?void 0:t.message)||String(t),isComplete:!0}),t}}chrome.runtime.onMessage.addListener((e,s,o)=>{var U;const G=(e==null?void 0:e.type)||(e==null?void 0:e.action);return console.log("üîç DEBUG: Background received message:",G),console.log("üîç DEBUG: Request details:",e),console.log("üîç DEBUG: Sender details:",s),G==="start_discovery"?(console.log("üöÄ DEBUG: Processing start_discovery request..."),chrome.tabs.query({active:!0,currentWindow:!0},async p=>{const t=p==null?void 0:p[0];if(console.log("üîç DEBUG: Active tab found:",{id:t==null?void 0:t.id,url:t==null?void 0:t.url,title:t==null?void 0:t.title}),!t||!t.id||!t.url){console.error("‚ùå DEBUG: No active tab found"),o({success:!1,error:"No active tab found"});return}if(t.url.startsWith("chrome://")||t.url.startsWith("chrome-extension://")){console.error("‚ùå DEBUG: Cannot run on internal pages:",t.url),o({success:!1,error:"Cannot run on internal pages"});return}console.log("üì§ DEBUG: Requesting snapshot from content script...");try{await new Promise(l=>{const c=setTimeout(()=>l(null),500);chrome.tabs.sendMessage(t.id,{action:"ping"},r=>{clearTimeout(c),l(r)})})?console.log("‚úÖ DEBUG: Content script already responsive"):(console.log("üîÑ DEBUG: Content script not responsive, injecting..."),await chrome.scripting.executeScript({target:{tabId:t.id},files:["content/contentScript.js"]}),console.log("‚úÖ DEBUG: Content script injection completed"),await new Promise(l=>setTimeout(l,200)))}catch(n){console.error("‚ùå DEBUG: Content script injection failed:",n),o({success:!1,error:"Cannot access this page. Please try on a different website or refresh the page."});return}chrome.tabs.sendMessage(t.id,{action:"extract_snapshot"},async n=>{if(chrome.runtime.lastError){console.error("‚ùå DEBUG: Error getting snapshot:",chrome.runtime.lastError.message);try{console.log("üîÑ DEBUG: Retrying with script re-injection..."),await chrome.scripting.executeScript({target:{tabId:t.id},files:["content/contentScript.js"]}),await new Promise(l=>setTimeout(l,200)),chrome.tabs.sendMessage(t.id,{action:"extract_snapshot"},l=>{var c;if(chrome.runtime.lastError||!l){console.error("‚ùå DEBUG: Retry also failed:",(c=chrome.runtime.lastError)==null?void 0:c.message),o({success:!1,error:"Content script not responding. Please refresh the page and try again."});return}console.log("‚úÖ DEBUG: Retry successful, got snapshot"),u(l)});return}catch(l){console.error("‚ùå DEBUG: Script injection retry failed:",l),o({success:!1,error:"Cannot inject content script. Page may not support extensions."});return}}u(n)});function u(n){var c,r;if(!n){console.error("‚ùå DEBUG: Snapshot response empty"),o({success:!1,error:"Snapshot response empty"});return}console.log("‚úÖ DEBUG: Snapshot received:",{url:n.url,textLength:(c=n.text)==null?void 0:c.length,linksCount:(r=n.links)==null?void 0:r.length}),console.log("üì§ DEBUG: Sending success response to popup..."),o({success:!0,message:"Streaming analysis started - jobs will appear as they are found",streaming:!0});const l=e.maxJobs||5;console.log("ü§ñ DEBUG: Starting discoveryWithPromptAPI with maxJobs:",l);try{const d=w(n,l,t.id);d&&typeof d.catch=="function"?d.catch(h=>{console.error("‚ùå DEBUG: discovery failed:",h)}):console.warn("‚ö†Ô∏è DEBUG: discoveryWithPromptAPI did not return a promise")}catch(d){console.error("‚ùå DEBUG: Error starting discovery:",d)}}}),!0):G==="TOGGLE_OVERLAY"?(U=s.tab)!=null&&U.id?(chrome.tabs.sendMessage(s.tab.id,{type:"TOGGLE_OVERLAY"},p=>{o(p||{success:!1})}),!0):(o({success:!1,error:"No sender tab available"}),!1):(o({success:!1,error:"Unknown action"}),!1)});
